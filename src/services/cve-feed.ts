/**
 * CVE / Vulnerability Feed Service
 *
 * Fetches real-time CVE data from free public APIs:
 *   - NVD API v2  (https://services.nvd.nist.gov/rest/json/cves/2.0)
 *   - CISA KEV    (Known Exploited Vulnerabilities catalog)
 *
 * Results are cached for 10 minutes to respect NVD rate limits
 * (5 requests per 30 seconds without an API key).
 */

import type { CVEItem, CVESeverity } from '@/types';

// ── NVD API response shapes ─────────────────────────────────────────

interface NvdCvssV31 {
  cvssData: {
    baseScore: number;
    vectorString: string;
    baseSeverity: string;
  };
}

interface NvdCvssV2 {
  cvssData: {
    baseScore: number;
    vectorString: string;
  };
  baseSeverity?: string;
}

interface NvdWeakness {
  description: Array<{ lang: string; value: string }>;
}

interface NvdReference {
  url: string;
  source?: string;
}

interface NvdCpeMatch {
  criteria: string;
  vulnerable: boolean;
}

interface NvdNode {
  cpeMatch?: NvdCpeMatch[];
}

interface NvdConfiguration {
  nodes?: NvdNode[];
}

interface NvdCveItem {
  id: string;
  descriptions: Array<{ lang: string; value: string }>;
  metrics?: {
    cvssMetricV31?: NvdCvssV31[];
    cvssMetricV30?: NvdCvssV31[];
    cvssMetricV2?: NvdCvssV2[];
  };
  weaknesses?: NvdWeakness[];
  configurations?: NvdConfiguration[];
  references?: NvdReference[];
  published: string;
  lastModified: string;
}

interface NvdApiResponse {
  resultsPerPage: number;
  startIndex: number;
  totalResults: number;
  vulnerabilities: Array<{ cve: NvdCveItem }>;
}

// ── CISA KEV response shapes ────────────────────────────────────────

interface CisaKevEntry {
  cveID: string;
  vendorProject: string;
  product: string;
  vulnerabilityName: string;
  dateAdded: string;
  shortDescription: string;
  requiredAction: string;
  dueDate: string;
}

interface CisaKevResponse {
  title: string;
  catalogVersion: string;
  dateReleased: string;
  count: number;
  vulnerabilities: CisaKevEntry[];
}

// ── Cache ───────────────────────────────────────────────────────────

const CACHE_TTL_MS = 10 * 60 * 1000; // 10 minutes

interface Cache<T> {
  data: T;
  timestamp: number;
}

let _cveCache: Cache<CVEItem[]> | null = null;
let _kevCache: Cache<Set<string>> | null = null;
let _fetching = false;

// ── Helpers ─────────────────────────────────────────────────────────

function cvssToSeverity(score: number | null): CVESeverity {
  if (score === null) return 'NONE';
  if (score >= 9.0) return 'CRITICAL';
  if (score >= 7.0) return 'HIGH';
  if (score >= 4.0) return 'MEDIUM';
  if (score > 0) return 'LOW';
  return 'NONE';
}

function extractCvss(metrics: NvdCveItem['metrics']): { score: number | null; vector: string | null; severity: CVESeverity } {
  if (!metrics) return { score: null, vector: null, severity: 'NONE' };

  // Prefer CVSS v3.1 > v3.0 > v2
  const v31 = metrics.cvssMetricV31?.[0];
  if (v31) {
    return {
      score: v31.cvssData.baseScore,
      vector: v31.cvssData.vectorString,
      severity: (v31.cvssData.baseSeverity?.toUpperCase() as CVESeverity) || cvssToSeverity(v31.cvssData.baseScore),
    };
  }

  const v30 = metrics.cvssMetricV30?.[0];
  if (v30) {
    return {
      score: v30.cvssData.baseScore,
      vector: v30.cvssData.vectorString,
      severity: (v30.cvssData.baseSeverity?.toUpperCase() as CVESeverity) || cvssToSeverity(v30.cvssData.baseScore),
    };
  }

  const v2 = metrics.cvssMetricV2?.[0];
  if (v2) {
    return {
      score: v2.cvssData.baseScore,
      vector: v2.cvssData.vectorString,
      severity: cvssToSeverity(v2.cvssData.baseScore),
    };
  }

  return { score: null, vector: null, severity: 'NONE' };
}

function extractProducts(configurations?: NvdConfiguration[]): string[] {
  if (!configurations) return [];
  const products = new Set<string>();

  for (const config of configurations) {
    for (const node of config.nodes ?? []) {
      for (const match of node.cpeMatch ?? []) {
        if (!match.vulnerable) continue;
        // CPE format: cpe:2.3:a:vendor:product:version:...
        const parts = match.criteria.split(':');
        if (parts.length >= 5) {
          const vendor = parts[3] ?? '';
          const product = parts[4] ?? '';
          if (vendor && product && vendor !== '*' && product !== '*') {
            products.add(`${vendor}:${product}`);
          }
        }
      }
    }
  }

  return Array.from(products).slice(0, 5);
}

function extractCweId(weaknesses?: NvdWeakness[]): string | null {
  if (!weaknesses || weaknesses.length === 0) return null;
  for (const w of weaknesses) {
    for (const desc of w.description) {
      if (desc.value && desc.value.startsWith('CWE-')) {
        return desc.value;
      }
    }
  }
  return null;
}

// ── CISA KEV fetch ──────────────────────────────────────────────────

async function fetchKevSet(): Promise<Set<string>> {
  // Return cached if fresh
  if (_kevCache && Date.now() - _kevCache.timestamp < CACHE_TTL_MS) {
    return _kevCache.data;
  }

  try {
    const res = await fetch(
      'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
      { signal: AbortSignal.timeout(15_000) },
    );

    if (!res.ok) throw new Error(`CISA KEV HTTP ${res.status}`);

    const data = (await res.json()) as CisaKevResponse;
    const kevSet = new Set<string>(data.vulnerabilities.map((v) => v.cveID));

    _kevCache = { data: kevSet, timestamp: Date.now() };
    return kevSet;
  } catch (err) {
    console.warn('[CVEFeed] CISA KEV fetch failed, using cached:', err);
    return _kevCache?.data ?? new Set();
  }
}

// ── NVD API fetch ───────────────────────────────────────────────────

async function fetchNvdCves(): Promise<NvdCveItem[]> {
  const res = await fetch(
    'https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=20',
    { signal: AbortSignal.timeout(20_000) },
  );

  if (!res.ok) {
    throw new Error(`NVD API HTTP ${res.status}`);
  }

  const data = (await res.json()) as NvdApiResponse;
  return data.vulnerabilities.map((v) => v.cve);
}

// ── Public API ──────────────────────────────────────────────────────

/**
 * Fetch the latest CVE items, cross-referenced against CISA KEV.
 * Results are cached for 10 minutes.
 */
export async function fetchCVEFeed(): Promise<CVEItem[]> {
  // Return cached if fresh
  if (_cveCache && Date.now() - _cveCache.timestamp < CACHE_TTL_MS) {
    return _cveCache.data;
  }

  // Prevent concurrent fetches
  if (_fetching && _cveCache) return _cveCache.data;
  _fetching = true;

  try {
    // Fetch NVD and KEV in parallel
    const [nvdCves, kevSet] = await Promise.all([
      fetchNvdCves(),
      fetchKevSet(),
    ]);

    const items: CVEItem[] = nvdCves.map((cve) => {
      const { score, vector, severity } = extractCvss(cve.metrics);
      const enDesc = cve.descriptions.find((d) => d.lang === 'en')?.value
        ?? cve.descriptions[0]?.value
        ?? 'No description available.';

      return {
        id: cve.id,
        description: enDesc,
        cvssScore: score,
        cvssVector: vector,
        severity,
        publishedDate: new Date(cve.published),
        lastModified: new Date(cve.lastModified),
        exploitedInWild: kevSet.has(cve.id),
        affectedProducts: extractProducts(cve.configurations),
        references: (cve.references ?? []).map((r) => r.url).slice(0, 3),
        epssScore: null, // EPSS requires a separate API call; omit for now
        cweId: extractCweId(cve.weaknesses),
      };
    });

    // Sort by published date descending
    items.sort((a, b) => b.publishedDate.getTime() - a.publishedDate.getTime());

    _cveCache = { data: items, timestamp: Date.now() };
    return items;
  } catch (err) {
    console.error('[CVEFeed] fetch failed:', err);
    // Fall back to cached data if available
    if (_cveCache) return _cveCache.data;
    throw err;
  } finally {
    _fetching = false;
  }
}

/** Clear the CVE cache so next call fetches fresh data. */
export function clearCVECache(): void {
  _cveCache = null;
}

/** Return cached data without fetching (may be null). */
export function getCachedCVEFeed(): CVEItem[] | null {
  return _cveCache?.data ?? null;
}
